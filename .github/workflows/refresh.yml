name: refresh

on:
  schedule:
    # 每天一次（UTC）
    - cron: '0 0 * * *'
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  fetch-and-encrypt:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository (allow pushing)
        uses: actions/checkout@v4
        with:
          persist-credentials: true

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests pycryptodome

      - name: Request token, encrypt and commit t.c
        env:
          BE_POST: ${{ secrets.BE_POST }}
          BE_HOST: ${{ secrets.BE_HOST }}
          BE_CT: ${{ secrets.BE_CT }}
          BE_UA: ${{ secrets.BE_UA }}
          BE_V: ${{ secrets.BE_V }}
          BE_K: ${{ secrets.BE_K }}
          BE_BODY: ${{ secrets.BE_BODY }}
        run: |
          python - <<'PY'
          import os, sys, time, json, base64, subprocess
          import requests
          from Crypto.Cipher import AES

          
          url = os.getenv('BE_POST')
          if not url:
              print('ERROR: BE_POST is not set', file=sys.stderr); sys.exit(1)

          
          raw_host = os.getenv('BE_HOST','').strip()
          raw_ct = os.getenv('BE_CT','').strip()
          raw_ua = os.getenv('BE_UA','').strip()

          headers = {}
          # helper: parse secret like 'Host: go.bemfa.com' 或者 'go.bemfa.com'
          def parse_header(raw, default_name):
              if not raw:
                  return None, None
              if ':' in raw:
                  k, v = raw.split(':',1)
                  return k.strip(), v.strip()
             
              return default_name, raw

          hname, hval = parse_header(raw_host, 'Host')
          if hname and hval:
              headers[hname] = hval
          hname, hval = parse_header(raw_ct, 'Content-Type')
          if hname and hval:
              headers[hname] = hval
          hname, hval = parse_header(raw_ua, 'User-Agent')
          if hname and hval:
              headers[hname] = hval

          
          be_body = os.getenv('BE_BODY','').strip()
          if not be_body:
              print('ERROR: BE_BODY is not set', file=sys.stderr); sys.exit(1)

          try:
              
              payload = json.loads(be_body)
          except Exception as e:
              print('ERROR: BE_BODY is not valid JSON:', e, file=sys.stderr); sys.exit(1)

         
          be_v_b64 = os.getenv('BE_V')
          be_k_b64 = os.getenv('BE_K')
          if not be_v_b64 or not be_k_b64:
              print('ERROR: BE_V and BE_K must be set (base64).', file=sys.stderr); sys.exit(1)
          try:
              iv = base64.b64decode(be_v_b64)
              key = base64.b64decode(be_k_b64)
          except Exception as e:
              print('ERROR: failed to base64-decode BE_V/BE_K:', e, file=sys.stderr); sys.exit(1)

          if len(iv) != 16 or len(key) != 16:
              print(f'ERROR: expect 16 bytes iv and 16 bytes key. got iv={len(iv)} key={len(key)}', file=sys.stderr); sys.exit(1)

          
          max_attempts = 3
          wait_seconds = 3
          token = None
          last_err = None

          for attempt in range(1, max_attempts+1):
              try:
                  
                  resp = requests.post(url, headers=headers, json=payload, timeout=15)
                  if resp.status_code != 200:
                      raise Exception(f'HTTP {resp.status_code}: {resp.text[:300]}')
                  j = resp.json()
                 
                  if isinstance(j, dict):
                      data = j.get('data') or {}
                      if isinstance(data, dict):
                          token = data.get('token')
                      if not token:
                          token = j.get('token')
                  if not token:
                      raise Exception('token not found in response JSON')
                  print(f'Attempt {attempt}: token fetched, length {len(token)}')
                  break
              except Exception as e:
                  last_err = e
                  print(f'Attempt {attempt} failed: {e}')
                  if attempt < max_attempts:
                      print(f'Retrying after {wait_seconds}s...')
                      time.sleep(wait_seconds)
                      continue
                  else:
                      print('All attempts failed.', file=sys.stderr)
                      print('Last error:', last_err, file=sys.stderr)
                      sys.exit(1)

         
          def pkcs7_pad(b: bytes, block_size=16):
              pad_len = block_size - (len(b) % block_size)
              return b + bytes([pad_len]) * pad_len

          token_bytes = token.encode('utf-8')
          padded = pkcs7_pad(token_bytes, 16)
          cipher = AES.new(key, AES.MODE_CBC, iv)
          ct = cipher.encrypt(padded)
          ct_b64 = base64.b64encode(ct).decode('ascii')

          out_path = 't.c'
          with open(out_path, 'w', encoding='utf-8') as f:
              f.write(ct_b64 + '\n')

          
          def run(cmd):
              print('+ ' + ' '.join(cmd))
              subprocess.check_call(cmd)

          run(['git', 'config', '--global', 'user.email', 'github-actions[bot]@users.noreply.github.com'])
          run(['git', 'config', '--global', 'user.name', 'github-actions[bot]'])
          run(['git', 'add', out_path])
          try:
              run(['git', 'commit', '-m', 'Update (t.c)'])
          except subprocess.CalledProcessError:
              print('No changes to commit.')
          else:
              run(['git', 'push', 'origin', 'HEAD'])

          print('Done.')
          PY
