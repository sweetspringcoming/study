name: check-os-daily

on:
  schedule:
    - cron: "0 0 * * *"  # 每天 00:00 UTC 执行
  workflow_dispatch:

jobs:
  fetch-and-encrypt:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests pycryptodome

      - name: Fetch token and encrypt
        env:
          BE_POST: ${{ secrets.BE_POST }}
          BE_HOST: ${{ secrets.BE_HOST }}
          BE_CT: ${{ secrets.BE_CT }}
          BE_UA: ${{ secrets.BE_UA }}
          BE_BODY: ${{ secrets.BE_BODY }}
          AES_KEY_FILE: ${{ secrets.AES_KEY_FILE }}   
          AES_IV_FILE: ${{ secrets.AES_IV_FILE }}    
        run: |
          python - <<EOF
          import os, json, time, base64, re
          import requests
          from Crypto.Cipher import AES
          from Crypto.Util.Padding import pad

          def load_clean_hex(filepath):
              with open(filepath, 'r') as f:
                  line = f.readline()
              clean_hex = re.sub(r'[^0-9a-fA-F]', '', line)
              return bytes.fromhex(clean_hex)

          key = load_clean_hex(os.environ["AES_KEY_FILE"])
          iv = load_clean_hex(os.environ["AES_IV_FILE"])

          url = os.environ["BE_POST"]
          headers = {
              "Host": os.environ["BE_HOST"].split(':',1)[1].strip(),
              "Content-Type": os.environ["BE_CT"],
              "User-Agent": os.environ["BE_UA"]
          }
          data = json.loads(os.environ["BE_BODY"])

          max_attempts = 3
          for attempt in range(1, max_attempts+1):
              try:
                  resp = requests.post(url, headers=headers, json=data, timeout=15)
                  resp.raise_for_status()
                  token = resp.json().get("data", {}).get("token")
                  if not token:
                      raise ValueError("t获取失败")
                  break
              except Exception as e:
                  if attempt < max_attempts:
                      print(f"{attempt} 次失败，3秒后重试...")
                      time.sleep(3)
                  else:
                      raise RuntimeError(f"获取t失败，已尝试 {max_attempts} 次") from e

        
          cipher = AES.new(key, AES.MODE_CBC, iv)
          ciphertext = cipher.encrypt(pad(token.encode(), AES.block_size))
          enc_b64 = base64.b64encode(ciphertext).decode()

          with open("t.c", "w") as f:
              f.write(enc_b64)

          print("t写入")
          EOF

      - name: Commit encrypted token
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add t.c
          git commit -m "Ut"
          git push
